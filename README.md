# Отчёт по расчётной работе по дисциплине ПиОИвИС


## Цель
Ознакомится с основнами теории графов, способами предсставления графов, базовыми алгоритмами для работы с разными видами графов.


## Задача
Составить список инцидентности, определить степени рёбер неопределнного мультиграфа.


## ![](./image/Снимок%20экрана%202024-12-16%20215136.png)


## Вариант 5.30(нмг, ми)


## Ключевые понятия 
- Графовая структура (абсолютное понятие)  это такая одноуровневая реляционная структура, объекты которой могут играть роль либо вершины, либо связки;
  - Вершина (относительное понятие, ролевое отношение);
  -  Связка (относительное понятие, ролевое отношение).
- Графовая структура с ориентированными связками (абсолютное понятие)
  -Ориентированная связка (относительное понятие, ролевое отношение) – связка, которая задается ориентированным множеством.
-Графовая структура с неориентированными связками (абсолютное понятие)
   -Неориентированная связка (относительное понятие, ролевое отношение)– связка, которая задается неориентированным множеством.
-Гиперграф (абсолютное понятие) – это такая графовая структура, в которой связки могут связывать только вершины;
  -Гиперсвязка (относительное понятие, ролевое отношение);
   -Гипердуга (относительное понятие, ролевое отношение) – ориентированная гипер-связка;
    -Гиперребро (относительное понятие, ролевое отношение) – неориентированная гипер-связка.
-Псевдограф (абсолютное понятие) – это такой гиперграф, в котором все связки должны быть бинарными;
    -Бинарная связка (относительное понятие, ролевое отношение) – гиперсвязка арности 2;
    -Ребро (относительное понятие, ролевое отношение) – неориентированная гиперсвязка;
    -Дуга (относительное понятие, ролевое отношение) – ориентированная гиперсвязка;
    -Петля (относительное понятие, ролевое отношение) – бинарная связка, у которой первый и второй компоненты совпадают.
-Мультиграф (абсолютное понятие) – это такой псевдограф, в котором не может быть петель;
-Граф (абсолютное понятие) – это такой мультиграф, в котором не может быть кратных связок, т.е. связок у которых первый и второй компоненты совпадают;
-Неориентированный граф (абсолютное понятие) – это такой граф, в котором все связки являются ребрами;
-Ориентированный граф (абсолютное понятие) - это такой граф, в котором все связки являются дугами;
-Матрица инцидентности - матрица размера _mxn_, где _n_ - количетво вершин, а _m_- колиество рёбер в графе.


## Алгоритм решения
  1. **Ввод данных**
 1.1 Считываем количество вершин мультиграфа.
 1.2 Считываем количество рёбер мультиграфа.
 1.3 Считываем матрицу инцидентности, представляющую мультиграф.
  2. **Определение степеней рёбер**
2.1 Создаём множество степеней вершин(МСВ).
2.2 Заполняем МСВ для кадой вершины:
2.2.1 Считываем из матрицы инцидентности сколько рёбер инцидентно данной вершине и записываем их количество в МСВ.
2.2 Определяем рёбра в матрице инцидентности и вершины, которые их связывают:
2.2.1 Проходим по матрице сверху вниз для каждого ребра по двум счётчикам, соответсвующих вершинам графа: первый(m) для текущего сравниваемого значения матрицы, второй(j) для остальных значений, которые ещё не были первом счётчике.
2.2.2 Если значения матрицы относительно обоих счётчиков равны(mi==ji) и равны единице:
2.2.3 То определям ребро i между вершинами m и j.
2.2.4 Определяем степень ребра i произведением степеней вершин m и j.


  3. **Вывод результата**
4.1 После прохождения по всем рёбрам выводим их в виде списка инцидентности и кажому ребру соответсвенно его степень(в списке отдельной колнкой).
**Пример кода**
'''c++
 #include <vector>
#include <iostream>
using namespace std;
int main() {
	setlocale(LC_ALL, "Russian");
	int rebro, versh, k = 0;
	bool flag = false;
	cout << "Ââåäèòå êîë-âî âåðøèí â íåîðèåíòèðîâàííîììóëüòèãðàôå: ";
	cin >> versh;
	cout << endl << "Ââåäèòå êîë-âî ðåáåð â íåîðèåíòèðîâàííîììóëüòèãðàôå: ";
	cin >> rebro;
	vector<vector<int>> matricaINC(versh, vector<int>(rebro));
	do {
		flag = false;
		cout << endl << "Çàïîëíèòå ìàòðèöó èíöèäåíòíîñòè: " << endl << "   ";
		for (int i = 0; i < rebro; i++)
			cout << 'R' << i + 1 << " ";
		for (int i = 0; i < versh; i++) {
			cout << endl << 'V' << i + 1 << ' ';
			for (int j = 0; j < rebro; j++) {
				cin >> matricaINC[i][j];
				if (matricaINC[i][j] != 0 && matricaINC[i][j] != 1) {
					cout << "ýòî íå ìàòðèöà èíöèäåíòíîñòè ìóëüòèãðàôà";
					flag = true;
					break;
				}
			}
		}
			for (int m = 0; m < versh-1; m++) {
				for (int j = 0; j < rebro; j++) {
					k = 0;
					for (int i = m + 1; i < versh; i++)
						if (matricaINC[m][j] == matricaINC[i][j] && matricaINC[m][j] == 1)
							k++;
					if (k >= 2) {
						cout << "ýòî íå ìàòðèöà èíöèäåíòíîñòè ìóëüòèãðàôà";
						flag = true;
						break;
					}
				}
				if (flag)
					break;
			}
		} while (flag);
		cout << endl << "Ñïèñîê èíöèäåíòíîñòè ïî ð¸áðàì è èõ ñòåïåíè:";
		cout << endl<<"Ð¸áðà" << " " << "Âåðøèíû" << " Ñòåïåíè";
		vector<int> stepeni(versh);
		for (int i = 0; i < versh; i++)
			stepeni[i] = 0;
		for (int j = 0; j < versh; j++)
			for (int i = 0; i < rebro; i++)
				if (matricaINC[j][i] == 1)
					stepeni[j]++;
		for (int j = 0; j < rebro; j++) {
			cout << endl<<"R" << j+1 << "      ";
			flag = false;
			for (int m = 0; m < versh-1; m++) {
				for (int i = m + 1; i < versh; i++)
					if (matricaINC[m][j] == matricaINC[i][j] && matricaINC[m][j] == 1) {
						cout << 'V' << m+1 << ", " << 'V' << i+1<<"	   "<<stepeni[m] * stepeni[i];
						flag = true;
						break;
					}
				if (flag)
					break;
			}
		}
		return -105;
	}
'''

## Тестовый пример
### Матричный вид:


|1|0|1|0|0|0|
|1|1|0|0|0|1|
|0|0|0|1|1|0|
|0|1|1|1|1|1|
|0|0|0|0|0|0|


![](./image/Снимок%20экрана%202024-12-17%20181756.png)


## Вывод
В результате выполнения данной работы были получены следующие пркатические навыки: изучены основы теории графов, изучены способы представления графов, изучены базовые алгоритмы для работы с графами.

